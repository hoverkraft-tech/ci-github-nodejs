name: "Get package manager"
description: "Action to detect the package manager used. Supports Yarn, pnpm, and npm"
author: hoverkraft
branding:
  icon: package
  color: blue

inputs:
  working-directory:
    description: |
      Working directory where the dependencies are installed.
      Can be absolute or relative to the repository root.
    required: false
    default: "."

outputs:
  package-manager:
    description: "The package manager used."
    value: ${{ steps.get-package-manager.outputs.package-manager }}
  cache-dependency-path:
    description: "The path to the dependency file for cache management."
    value: ${{ steps.get-package-manager.outputs.cache-dependency-path }}
  install-command:
    description: "The command to install dependencies."
    value: ${{ steps.get-package-manager.outputs.install-command }}
  run-script-command:
    description: "The command to run a script in the package.json file."
    value: ${{ steps.get-package-manager.outputs.run-script-command }}

runs:
  using: "composite"
  steps:
    - id: get-package-manager
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      env:
        WORKING_DIRECTORY: ${{ inputs.working-directory }}
      with:
        # jscpd:ignore-start
        script: |
          const fs = require('node:fs');
          const path = require('node:path');

          let workingDirectory = process.env.WORKING_DIRECTORY || '.';
          if (!path.isAbsolute(workingDirectory)) {
            workingDirectory = path.join(process.env.GITHUB_WORKSPACE, workingDirectory);
          }
          core.debug(`Resolved working directory: ${workingDirectory}`);

          if (!fs.existsSync(workingDirectory)) {
            core.setFailed(`The specified working directory does not exist: ${workingDirectory}`);
            return;
          }

          workingDirectory = path.resolve(workingDirectory);
          core.debug(`Running in working directory: ${workingDirectory}`);
          process.chdir(workingDirectory);

          let packageManagerName = '';
          const packageJsonPath = path.join(workingDirectory, 'package.json');

          if (fs.existsSync(packageJsonPath)) {
            try {
              const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
              const packageManager = packageJson?.packageManager;

              if (typeof packageManager === 'string' && packageManager.trim() !== '') {
                packageManagerName = packageManager.split('@')[0];
              }
            } catch (error) {
              core.warning(`Failed to parse package.json: ${error.message}`);
            }
          }

          core.debug(`Package manager from package.json: ${packageManagerName}`);

          if (!packageManagerName) {
            const lockFiles = [
              { file: 'yarn.lock', name: 'yarn' },
              { file: 'pnpm-lock.yaml', name: 'pnpm' },
              { file: 'package-lock.json', name: 'npm' },
            ];

            const detectedLockFile = lockFiles.find(({ file }) => fs.existsSync(path.join(workingDirectory, file)));

            if (!detectedLockFile) {
              core.setFailed(`Unable to detect package manager lock file. Supported lock files are: ${lockFiles.map(f => f.file).join(", ")}`);
              return;
            }

            packageManagerName = detectedLockFile.name;
            core.debug(`Package manager from lock files: ${packageManagerName}`);
          }

          let relativeWorkingDirectory = path.relative(process.env.GITHUB_WORKSPACE, workingDirectory) || '.';
          core.debug(`Relative working directory to GITHUB_WORKSPACE (${process.env.GITHUB_WORKSPACE}): ${relativeWorkingDirectory}`);

          let cacheDependencyPathPrefix = relativeWorkingDirectory;

          if (relativeWorkingDirectory.startsWith('../')) {
            // Working directory is outside GITHUB_WORKSPACE
            // Create a symlink inside GITHUB_WORKSPACE to enable caching
            const symlinkName = '.ci-github-nodejs-cache';
            const symlinkPath = path.join(process.env.GITHUB_WORKSPACE, symlinkName);
            const ensureIgnoreEntry = (filePath, entry) => {
              const normalizedEntry = entry.trim();
              if (!normalizedEntry) {
                return;
              }

              if (fs.existsSync(filePath)) {
                const contents = fs.readFileSync(filePath, 'utf8');
                const lines = contents.split(/\r?\n/);

                if (lines.includes(normalizedEntry)) {
                  return;
                }

                const needsNewline = contents.length > 0 && !contents.endsWith('\n');
                const prefix = needsNewline ? '\n' : '';
                fs.appendFileSync(filePath, `${prefix}${normalizedEntry}\n`);
                return;
              }

              fs.writeFileSync(filePath, `${normalizedEntry}\n`);
            };

            try {
              // Remove existing symlink if it exists
              if (fs.existsSync(symlinkPath)) {
                fs.unlinkSync(symlinkPath);
              }

              // Create symlink pointing to the working directory
              fs.symlinkSync(workingDirectory, symlinkPath, 'dir');
              core.info(`Created symlink at "${symlinkPath}" pointing to "${workingDirectory}" to enable caching.`);

              const gitignorePath = path.join(process.env.GITHUB_WORKSPACE, '.gitignore');
              const dockerignorePath = path.join(process.env.GITHUB_WORKSPACE, '.dockerignore');
              ensureIgnoreEntry(gitignorePath, symlinkName);
              ensureIgnoreEntry(dockerignorePath, symlinkName);

              cacheDependencyPathPrefix = symlinkName;
            } catch (error) {
              core.warning(`Failed to create symlink for caching: ${error.message}. Caching will be disabled.`);
              cacheDependencyPathPrefix = '';
            }
          }

          core.debug(`Cache dependency path prefix: ${cacheDependencyPathPrefix}`);

          const packageManagerConfig = {
            yarn: {
              cacheDependencyPath: cacheDependencyPathPrefix ? `${cacheDependencyPathPrefix}/**/yarn.lock` : '',
              installCommand: 'yarn install --frozen-lockfile',
              runScriptCommand: 'yarn',
            },
            pnpm: {
              cacheDependencyPath: cacheDependencyPathPrefix ? `${cacheDependencyPathPrefix}/**/pnpm-lock.yaml` : '',
              installCommand: 'pnpm install --frozen-lockfile',
              runScriptCommand: 'pnpm',
            },
            npm: {
              cacheDependencyPath: cacheDependencyPathPrefix ? `${cacheDependencyPathPrefix}/**/package-lock.json` : '',
              installCommand: 'npm ci',
              runScriptCommand: 'npm run',
            },
          };

          const managerConfig = packageManagerConfig[packageManagerName];

          if (!managerConfig) {
            core.setFailed(`Package manager ${packageManagerName} is not supported`);
            return;
          }

          core.setOutput('package-manager', packageManagerName);
          core.setOutput('cache-dependency-path', managerConfig.cacheDependencyPath);
          core.setOutput('install-command', managerConfig.installCommand);
          core.setOutput('run-script-command', managerConfig.runScriptCommand);
        # jscpd:ignore-end
