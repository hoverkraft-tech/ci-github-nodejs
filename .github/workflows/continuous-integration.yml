# Workflow to performs continuous integration steps agains a Node.js project:
#
# - CodeQL analysis
# - Linting
# - Build
# - Test

name: Node.js Continuous Integration

on:
  workflow_call:
    inputs:
      runs-on:
        description: |
          JSON array of runner(s) to use.
          See https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job.
        type: string
        default: '["ubuntu-latest"]'
        required: false
      build:
        description: |
          Build parameters. Must be a string or a JSON object.
          For string, provide a list of commands to run during the build step, one per line.
          For JSON object, provide the following properties:

          - `commands`: Array of commands to run during the build step.
          - `env`: Object of environment variables to set during the build step.
          - `artifact`: String or array of strings specifying paths to artifacts to upload after the build

          Example:
          ```json
          {
            "commands": [
              "build",
              "generate-artifacts"
            ],
            "env": {
              "CUSTOM_ENV_VAR": "value"
            },
            "artifact": [
              "dist/",
              "packages/package-a/build/"
            ]
          }
          ```
        type: string
        required: false
        default: "build"
      checks:
        description: "Optional flag to enable check steps."
        type: boolean
        required: false
        default: true
      lint:
        description: |
          Whether to enable linting.
          Set to `null` or empty to disable.
          Accepts a JSON object for lint options. See [lint action](../../actions/lint/README.md).
          It should generate lint reports in standard formats.

          Example:

          ```json:package.json
          {
            "lint:ci": "eslint . --output-file eslint-report.json --format json"
          }
          ```
        type: string
        required: false
        default: "true"
      code-ql:
        description: |
          Code QL analysis language.
          See https://github.com/github/codeql-action.
        type: string
        required: false
        default: "typescript"
      dependency-review:
        description: |
          Enable dependency review scan.
          Works with public repositories and private repositories with a GitHub Advanced Security license.
          See https://github.com/actions/dependency-review-action.
        type: boolean
        required: false
        default: true
      test:
        description: |
          Whether to enable testing.
          Set to `null` or empty to disable.
          Accepts a JSON object for test options. See [test action](../../actions/test/README.md).
          If coverage is enabled, it should generate test and coverage reports in standard formats.

          Example:

          ```json:package.json
          {
            "test:ci": "vitest run --reporter=default --reporter=junit --outputFile=junit.xml --coverage.enabled --coverage.reporter=lcov --coverage.reporter=text"
          }
          ```
        type: string
        required: false
        default: "true"
      working-directory:
        description: "Working directory where the dependencies are installed."
        type: string
        required: false
        default: "."
      container:
        description: |
          Container configuration to run CI steps in.
          Accepts either a string (container image name) or a JSON object with container options.

          String format (simple):

          ```yml
          container: "node:18"
          ```

          JSON object format (advanced):

          ```json
          {
            "image": "node:18",
            "env": {
              "NODE_ENV": "production"
            },
            "options": "--cpus 2",
            "ports": [8080, 3000],
            "volumes": ["/tmp:/tmp", "/cache:/cache"],
            "credentials": {
              "username": "myusername"
            },
            pathMapping: {
              "/app": "./relative/path/to/app"
            }
          }
          ```

          Supported properties:

          - `image` (required)
          - `env` (object)
          - `options` (string)
          - `ports` (array)
          - `volumes` (array)
          - `credentials` (object with `username`).
          - `pathMapping` (object) path mapping from container paths to repository paths. Defaults is working directory is mapped with repository root.

          See https://docs.github.com/en/actions/how-tos/write-workflows/choose-where-workflows-run/run-jobs-in-a-container.

          When specified, steps will execute inside this container instead of checking out code.
          The container should have the project code and dependencies pre-installed.
        type: string
        required: false
        default: ""
    secrets:
      build-secrets:
        description: |
          Secrets to be used during the build step.
          Must be a multi-line env formatted string.
          Example:
          ```txt
          SECRET_EXAMPLE=$\{{ secrets.SECRET_EXAMPLE }}
          ```
        required: false
      container-password:
        description: |
          Password for container registry authentication, if required.
          Used when the container image is hosted in a private registry.
          See https://docs.github.com/en/actions/how-tos/write-workflows/choose-where-workflows-run/run-jobs-in-a-container#defining-credentials-for-a-container-registry.
        required: false
      github-token:
        description: |
          GitHub token to use for authentication.
          Defaults to `GITHUB_TOKEN` if not provided.
        required: false
    outputs:
      build-artifact-id:
        description: "ID of the build artifact) uploaded during the build step."
        value: ${{ jobs.build.outputs.artifact-id }}

permissions: {}

jobs:
  prepare:
    name: ðŸ“¦ Prepare configuration
    runs-on: &ci-runner ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    permissions: {}
    outputs:
      container-image: ${{ steps.parse.outputs.container-image }}
      container-env: ${{ steps.parse.outputs.container-env }}
      container-options: ${{ steps.parse.outputs.container-options }}
      container-ports: ${{ steps.parse.outputs.container-ports }}
      container-volumes: ${{ steps.parse.outputs.container-volumes }}
      container-username: ${{ steps.parse.outputs.container-username }}
      path-mapping: ${{ steps.parse.outputs.path-mapping }}
    steps:
      - id: parse
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          CONTAINER_INPUT: ${{ inputs.container }}
          CONTAINER_PASSWORD: ${{ secrets.container-password }}
          WORKING_DIRECTORY: ${{ inputs.working-directory }}
        with:
          script: |
            const containerInput = process.env.CONTAINER_INPUT.trim();
            if (!containerInput) {
              return;
            }
            core.debug(`Container input: ${containerInput}`);

            // Check if input is a JSON object or a simple string
            const isJson = containerInput.startsWith('{');

            let container = {
              options: '--user root:root'
            };

            let pathMapping = {
              [process.env.WORKING_DIRECTORY || '.']: process.env.GITHUB_WORKSPACE,
            };

            if (isJson) {
              try {
                const {pathMapping: parsedPathMapping, ...parsedContainer} = JSON.parse(containerInput);
                core.debug(`Parsed container input as JSON: ${JSON.stringify(parsedContainer)}`);

                container = {
                  ...container,
                  ...parsedContainer,
                  options: `${container.options} ${parsedContainer.options || ''}`.trim()
                };

                core.debug(`Parsed path mapping: ${JSON.stringify(parsedPathMapping)}`);
                if (parsedPathMapping){
                  pathMapping = parsedPathMapping;
                }

              } catch (error) {
                return core.setFailed(`Failed to parse container input as JSON: ${error.message}`,{ cause: error });
              }
            } else {
              // Simple string format - just the image name
              container.image = containerInput;
            }

            core.debug(`Parsed container configuration: ${JSON.stringify(container)}`);

            if (!container.image) {
              return core.setFailed('Container image must be specified in the container input.');
            }
            core.setOutput('container-image', container.image);

            if (container.env) {
              core.setOutput('container-env', JSON.stringify(container.env));
            }

            if (container.options) {
              core.setOutput('container-options', container.options);
            }

            if (container.ports) {
              core.setOutput('container-ports', JSON.stringify(container.ports));
            }

            if (container.volumes) {
              core.setOutput('container-volumes', JSON.stringify(container.volumes));
            }

            if (container.credentials?.username) {
              core.setOutput('container-username', container.credentials.username);
              if (!process.env.CONTAINER_PASSWORD) {
                return core.setFailed('Container password must be provided when container credentials username is specified.');
              }
            } else if (process.env.CONTAINER_PASSWORD) {
              return core.setFailed('Container credentials username must be provided when container password is specified.');
            }

            core.debug(`Parsed path mapping: ${JSON.stringify(pathMapping)}`);
            if (!pathMapping || typeof pathMapping !== 'object' || Object.keys(pathMapping).length === 0){
              return core.setFailed('At least one path mapping must be specified in the container configuration.');
            }

            core.setOutput('path-mapping', Object.entries(pathMapping).reduce((acc, [containerPath, repoPath]) => {
              acc += `${acc?',' : ''}${containerPath}:${repoPath}`;
              return acc;
            }, ""));

  code-ql:
    name: ðŸ›¡ï¸ CodeQL Analysis
    if: inputs.checks == true && inputs.code-ql != ''
    permissions:
      security-events: write
    runs-on: *ci-runner
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@5e8d0e6d1e76d8577a070db6d0128a91b1c9d5ad # 0.30.2
      - uses: github/codeql-action/init@fdbfb4d2750291e159f0156def62b853c2798ca2 # v4.31.5
        with:
          languages: ${{ inputs.code-ql }}
      - uses: github/codeql-action/analyze@fdbfb4d2750291e159f0156def62b853c2798ca2 # v4.31.5

  dependency-review:
    name: ðŸ›¡ï¸ Dependency Review
    if: github.event_name == 'pull_request' && inputs.checks == true && inputs.dependency-review
    permissions:
      contents: read
    runs-on: *ci-runner
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@5e8d0e6d1e76d8577a070db6d0128a91b1c9d5ad # 0.30.2
      - uses: actions/dependency-review-action@3c4e3dcb1aa7874d2c16be7d79418e9b7efd6261 # v4.8.2

  setup:
    name: âš™ï¸ Setup
    runs-on: *ci-runner
    needs:
      - prepare
    permissions:
      contents: read
      packages: read
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    container: &ci-container
      image: ${{ needs.prepare.outputs.container-image || '' }}
      env: ${{ fromJSON(needs.prepare.outputs.container-env || '{}') }}
      options: ${{ needs.prepare.outputs.container-options || ' ' }}
      ports: ${{ fromJSON(needs.prepare.outputs.container-ports || '[]') }}
      volumes: ${{ fromJSON(needs.prepare.outputs.container-volumes || '[]') }}
      credentials: ${{ fromJSON(needs.prepare.outputs.container-username && format('{{"username":{0},"password":{1}}}',toJSON(needs.prepare.outputs.container-username),toJSON(secrets.container-password)) || '{}') }}
    outputs:
      working-directory: ${{ steps.working-directory.outputs.working-directory }}
      build-env: ${{ steps.build-variables.outputs.env }}
      build-commands: ${{ steps.build-variables.outputs.commands }}
      build-artifact: ${{ steps.build-variables.outputs.artifact }}
    steps:
      - name: Checkout repository
        if: inputs.container == ''
        uses: hoverkraft-tech/ci-github-common/actions/checkout@5e8d0e6d1e76d8577a070db6d0128a91b1c9d5ad # 0.30.2

      - id: working-directory
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          WORKING_DIRECTORY_INPUT: ${{ inputs.working-directory }}
        with:
          script: |
            const fs = require('node:fs');
            const path = require('node:path');

            let workingDirectory = process.env.WORKING_DIRECTORY_INPUT || '.';
            if (!path.isAbsolute(workingDirectory)) {
              workingDirectory = path.join(process.env.GITHUB_WORKSPACE, workingDirectory);
            }

            if (!fs.existsSync(workingDirectory)) {
              core.setFailed(`The specified working directory does not exist: ${workingDirectory}`);
              return;
            }
            workingDirectory = path.resolve(workingDirectory);
            core.debug(`Running in working directory: ${workingDirectory}`);
            core.setOutput('working-directory', workingDirectory);

      - id: build-variables
        if: inputs.build != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          WORKING_DIRECTORY: ${{ steps.working-directory.outputs.working-directory }}
          BUILD_INPUT: ${{ inputs.build }}
        with:
          script: |
            const path = require('node:path');

            const workingDirectory = process.env.WORKING_DIRECTORY;
            const buildInput = process.env.BUILD_INPUT.trim();

            let commands = [];
            let env = {};

            // Build commands is a list of command(s), one per line.
            const buildCommandsIsList = !buildInput.trim().startsWith('{') && !buildInput.trim().startsWith('[');
            if (buildCommandsIsList) {
              commands = buildInput.split('\n').map(command => command.trim()).filter(Boolean);
            } else {
              let build;
              try {
                build = JSON.parse(buildInput);
              } catch (error) {
                core.setFailed(`Failed to parse build input as JSON: ${error.message}`);
                return;
              }

              // Build commands is a JSON array of commands
              if (Array.isArray(build)) {
                commands = build;
              }
              // Build commands is a JSON object
              else {
                commands = build.commands ?? ["build"];
                env = build.env ?? {};

                if (build.artifact) {
                  buildArtifact = build.artifact;

                  if (typeof buildArtifact === 'string' || Array.isArray(buildArtifact)) {
                    buildArtifact = {
                      paths: buildArtifact
                    };
                  }

                  if (typeof buildArtifact.paths === 'string') {
                    buildArtifact.paths = buildArtifact.paths.split('\n');
                  } else if (!Array.isArray(buildArtifact.paths)) {
                    return core.setFailed('Build artifact paths must be a string or an array of strings');
                  }

                  buildArtifact.paths = buildArtifact.paths
                    .map(artifact => artifact.trim())
                    .filter(Boolean)
                    .map(artifact => {
                      // FIXME: Workaround to preserve full path to artifact
                      const fullpath = artifact.startsWith('/') ? artifact : path.join(workingDirectory, artifact);

                      // Add a wildcard to the first folder of the path
                      return fullpath.replace(/\/([^/]+)/, '/*$1');
                    }).join('\n');

                  if (!buildArtifact.paths) {
                    return core.setFailed('No valid build artifact paths found');
                  }

                  // Generate a unique name for the artifact
                  buildArtifact.name = `${process.env.GITHUB_JOB}-build-${process.env.GITHUB_RUN_ID}-${Math.random().toString(36).substring(2, 8)}`;

                  core.setOutput('artifact', JSON.stringify(buildArtifact));
                }
              }
            }

            if (commands.some(command => typeof command !== 'string')) {
              core.setFailed('Build commands array must only contain strings');
              return;
            }

            const sanitizedCommands = commands.map(command => command.trim()).filter(Boolean);
            if (!sanitizedCommands.length) {
              core.setFailed('No build commands found');
            }

            core.setOutput('commands', sanitizedCommands.join('\n'));
            core.setOutput('env', JSON.stringify(env));

  lint:
    if: inputs.checks == true && inputs.lint
    name: ðŸ‘• Lint
    runs-on: *ci-runner
    container: *ci-container
    needs:
      - prepare
      - setup
    permissions:
      contents: read
      packages: read
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@5e8d0e6d1e76d8577a070db6d0128a91b1c9d5ad # 0.30.2
        if: inputs.container == ''

      - id: oidc
        uses: ChristopherHX/oidc@73eee1ff03fdfce10eda179f617131532209edbd # v3
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
          sparse-checkout: |
            actions
      - run: |
          if [ -f .gitignore ]; then grep -q "self-workflow" .gitignore || echo "self-workflow" >> .gitignore; else echo "self-workflow" >> .gitignore; fi
          if [ -f .dockerignore ]; then grep -q "self-workflow" .dockerignore || echo "self-workflow" >> .dockerignore; else echo "self-workflow" >> .dockerignore; fi

      - id: preparel-lint-options
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          LINT_INPUT: ${{ inputs.lint }}
        with:
          script: |
            const lintInput = process.env.LINT_INPUT.trim();

            let lintOptions = {};
            if (lintInput && lintInput !== 'true') {
              try {
                const parsed = JSON.parse(lintInput);
                lintOptions = { ...lintOptions, ...parsed };
              } catch (error) {
                core.setFailed(`Failed to parse lint input as JSON: ${error.message}`);
                return;
              }
            }

            core.setOutput('command', lintOptions.command || 'lint:ci');
            core.setOutput('report-file', lintOptions['report-file'] || '');

      - name: Run lint
        uses: ./self-workflow/actions/lint
        with:
          working-directory: ${{ needs.setup.outputs.working-directory }}
          container: ${{ inputs.container != '' && 'true' || 'false' }}
          command: ${{ steps.preparel-lint-options.outputs.command }}
          report-file: ${{ steps.preparel-lint-options.outputs.report-file }}
          path-mapping: ${{ needs.prepare.outputs.path-mapping || '' }}

  build:
    if: inputs.checks == true
    name: ðŸ—ï¸ Build
    runs-on: *ci-runner
    container: *ci-container
    needs:
      - prepare
      - setup
    permissions:
      contents: read
      packages: read
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    outputs:
      artifact-id: ${{ steps.build.outputs.artifact-id }}
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@5e8d0e6d1e76d8577a070db6d0128a91b1c9d5ad # 0.30.2
        if: needs.setup.outputs.build-commands && inputs.container == ''

      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        if: needs.setup.outputs.build-commands
        uses: ChristopherHX/oidc@73eee1ff03fdfce10eda179f617131532209edbd # v3
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        if: needs.setup.outputs.build-commands
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
          sparse-checkout: |
            actions
      - if: needs.setup.outputs.build-commands
        run: |
          if [ -f .gitignore ]; then grep -q "self-workflow" .gitignore || echo "self-workflow" >> .gitignore; else echo "self-workflow" >> .gitignore; fi
          if [ -f .dockerignore ]; then grep -q "self-workflow" .dockerignore || echo "self-workflow" >> .dockerignore; else echo "self-workflow" >> .dockerignore; fi

      - id: build
        if: needs.setup.outputs.build-commands
        uses: ./self-workflow/actions/build
        with:
          container: ${{ inputs.container != '' && 'true' || 'false' }}
          working-directory: ${{ needs.setup.outputs.working-directory }}
          build-secrets: ${{ secrets.build-secrets }}
          build-commands: ${{ needs.setup.outputs.build-commands }}
          build-env: ${{ needs.setup.outputs.build-env }}
          build-artifact: ${{ needs.setup.outputs.build-artifact }}

  test:
    if: inputs.checks == true && inputs.test
    name: ðŸ§ª Test
    runs-on: *ci-runner
    container: *ci-container
    needs:
      - prepare
      - setup
      - build
    permissions:
      contents: read
      pull-requests: write
      packages: read
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@5e8d0e6d1e76d8577a070db6d0128a91b1c9d5ad # 0.30.2
        if: inputs.container == ''

      - if: needs.build.outputs.artifact-id && inputs.container == ''
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          artifact-ids: ${{ needs.build.outputs.artifact-id }}
          path: "/"

      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        uses: ChristopherHX/oidc@73eee1ff03fdfce10eda179f617131532209edbd # v3
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
          sparse-checkout: |
            actions
      - run: |
          if [ -f .gitignore ]; then grep -q "self-workflow" .gitignore || echo "self-workflow" >> .gitignore; else echo "self-workflow" >> .gitignore; fi
          if [ -f .dockerignore ]; then grep -q "self-workflow" .dockerignore || echo "self-workflow" >> .dockerignore; else echo "self-workflow" >> .dockerignore; fi

      - id: prepare-test-options
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          TEST_INPUT: ${{ inputs.test }}
        with:
          script: |
            const testInput = process.env.TEST_INPUT.trim();

            let testOptions = {};
            if (testInput && testInput !== 'true') {
              try {
                const parsed = JSON.parse(testInput);
                testOptions = { ...testOptions, ...parsed };
              } catch (error) {
                core.setFailed(`Failed to parse test input as JSON: ${error.message}`);
                return;
              }
            }

            if (testOptions.coverage === undefined) {
              testOptions.coverage = 'github';
            }
            core.setOutput('coverage', testOptions.coverage );
            core.setOutput('report-file', testOptions['report-file'] || '');
            core.setOutput('command', testOptions.command || 'test:ci');

      - name: Run tests
        uses: ./self-workflow/actions/test
        with:
          working-directory: ${{ needs.setup.outputs.working-directory }}
          container: ${{ inputs.container != '' && 'true' || 'false' }}
          command: ${{ steps.prepare-test-options.outputs.command }}
          coverage: ${{ steps.prepare-test-options.outputs.coverage }}
          report-file: ${{ steps.prepare-test-options.outputs.report-file }}
          path-mapping: ${{ needs.prepare.outputs.path-mapping || '' }}
          github-token: ${{ secrets.github-token || github.token }}
