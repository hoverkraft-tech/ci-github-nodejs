# Workflow to performs continuous integration steps agains a Node.js project:
#
# - CodeQL analysis
# - Linting
# - Build
# - Test

name: Node.js Continuous Integration

on:
  workflow_call:
    inputs:
      runs-on:
        description: |
          JSON array of runner(s) to use.
          See https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job.
        type: string
        default: '["ubuntu-latest"]'
        required: false
      build:
        description: |
          Build parameters. Must be a string or a JSON object.
          For string, provide a list of commands to run during the build step, one per line.
          For JSON object, provide the following properties:

          - `commands`: Array of commands to run during the build step.
          - `env`: Object of environment variables to set during the build step.
          - `artifact`: String or array of strings specifying paths to artifacts to upload after the build

          Example:
          ```json
          {
            "commands": [
              "build",
              "generate-artifacts"
            ],
            "env": {
              "CUSTOM_ENV_VAR": "value"
            },
            "artifact": [
              "dist/",
              "packages/package-a/build/"
            ]
          }
          ```
        type: string
        required: false
        default: "build"
      checks:
        description: "Optional flag to enable check steps."
        type: boolean
        required: false
        default: true
      lint:
        description: |
          Whether to enable linting.
          Set to `null` or empty to disable.
          Accepts a JSON object for lint options. See [lint action](../actions/lint/README.md).
        type: string
        required: false
        default: "true"
      code-ql:
        description: "Code QL analysis language. See <https://github.com/github/codeql-action>."
        type: string
        required: false
        default: "typescript"
      dependency-review:
        description: "Enable dependency review scan. See <https://github.com/actions/dependency-review-action>."
        type: boolean
        required: false
        default: true
      test:
        description: |
          Whether to enable testing.
          Set to `null` or empty to disable.
          Accepts a JSON object for test options. See [test action](../actions/test/README.md).
        type: string
        required: false
        default: "true"
      working-directory:
        description: "Working directory where the dependencies are installed."
        type: string
        required: false
        default: "."
      container:
        description: |
          Container configuration to run CI steps in.
          Accepts either a string (container image name) or a JSON object with container options.

          String format (simple):
          ```yml
          container: "node:18"
          ```

          JSON object format (advanced):
          ```json
          {
            "image": "node:18",
            "env": {
              "NODE_ENV": "production"
            },
            "options": "--cpus 2",
            "ports": [8080, 3000],
            "volumes": ["/tmp:/tmp", "/cache:/cache"],
            "credentials": {
              "username": "myusername"
            }
          }
          ```

          Supported properties: image (required), env (object), options (string), ports (array), volumes (array), credentials (object with username).

          See https://docs.github.com/en/actions/how-tos/write-workflows/choose-where-workflows-run/run-jobs-in-a-container

          When specified, steps will execute inside this container instead of checking out code.
          The container should have the project code and dependencies pre-installed.
        type: string
        required: false
        default: ""
    secrets:
      build-secrets:
        description: |
          Secrets to be used during the build step.
          Must be a multi-line env formatted string.
          Example:
          ```txt
          SECRET_EXAMPLE=$\{{ secrets.SECRET_EXAMPLE }}
          ```
        required: false
      container-password:
        description: |
          Password for container registry authentication, if required.
          Used when the container image is hosted in a private registry.
          See https://docs.github.com/en/actions/how-tos/write-workflows/choose-where-workflows-run/run-jobs-in-a-container#defining-credentials-for-a-container-registry.
        required: false
    outputs:
      build-artifact-id:
        description: "ID of the build artifact) uploaded during the build step."
        value: ${{ jobs.build.outputs.artifact-id }}

permissions: {}

jobs:
  prepare:
    name: ðŸ“¦ Prepare configuration
    runs-on: ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    permissions: {}
    outputs:
      container-image: ${{ steps.parse.outputs.container-image }}
      container-env: ${{ steps.parse.outputs.container-env }}
      container-options: ${{ steps.parse.outputs.container-options }}
      container-ports: ${{ steps.parse.outputs.container-ports }}
      container-volumes: ${{ steps.parse.outputs.container-volumes }}
      container-username: ${{ steps.parse.outputs.container-username }}
    steps:
      - id: parse
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          CONTAINER_INPUT: ${{ inputs.container }}
          CONTAINER_PASSWORD: ${{ secrets.container-password }}
        with:
          script: |
            const containerInput = process.env.CONTAINER_INPUT.trim();
            if (!containerInput) {
              return;
            }
            core.debug(`Container input: ${containerInput}`);

            // Check if input is a JSON object or a simple string
            const isJson = containerInput.startsWith('{');

            let container = {
              options: '--user root:root'
            };

            if (isJson) {
              try {
                const parsedContainer = JSON.parse(containerInput);
                core.debug(`Parsed container input as JSON: ${JSON.stringify(parsedContainer)}`);
                container = { 
                  ...container, 
                  ...parsedContainer,
                  options: `${container.options} ${parsedContainer.options || ''}`.trim()
                };

              } catch (error) {
                return core.setFailed(`Failed to parse container input as JSON: ${error.message}`,{ cause: error });
              }
            } else {
              // Simple string format - just the image name
              container.image = containerInput;
            }

            core.debug(`Parsed container configuration: ${JSON.stringify(container)}`);

            if (!container.image) {
              return core.setFailed('Container image must be specified in the container input.');
            }
            core.setOutput('container-image', container.image);

            if (container.env) {
              core.setOutput('container-env', JSON.stringify(container.env));
            }

            if (container.options) {
              core.setOutput('container-options', container.options);
            }

            if (container.ports) {
              core.setOutput('container-ports', JSON.stringify(container.ports));
            }

            if (container.volumes) {
              core.setOutput('container-volumes', JSON.stringify(container.volumes));
            }

            if (container.credentials?.username) {
              core.setOutput('container-username', container.credentials.username);
              if (!process.env.CONTAINER_PASSWORD) {
                return core.setFailed('Container password must be provided when container credentials username is specified.');
              }
            } else if (process.env.CONTAINER_PASSWORD) {
              return core.setFailed('Container credentials username must be provided when container password is specified.');
            }

  code-ql:
    name: ðŸ›¡ï¸ CodeQL Analysis
    if: inputs.checks == true && inputs.code-ql != ''
    permissions:
      security-events: write
    runs-on: ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@753288393de1f3d92f687a6761d236ca800f5306 # 0.28.1
      - uses: github/codeql-action/init@014f16e7ab1402f30e7c3329d33797e7948572db # v4.31.3
        with:
          languages: ${{ inputs.code-ql }}
      - uses: github/codeql-action/analyze@014f16e7ab1402f30e7c3329d33797e7948572db # v4.31.3

  dependency-review:
    name: ðŸ›¡ï¸ Dependency Review
    if: github.event_name == 'pull_request' && inputs.checks == true && inputs.dependency-review
    permissions:
      contents: read
    runs-on: ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@753288393de1f3d92f687a6761d236ca800f5306 # 0.28.1
      - uses: actions/dependency-review-action@3c4e3dcb1aa7874d2c16be7d79418e9b7efd6261 # v4.8.2

  setup:
    name: âš™ï¸ Setup
    runs-on: ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    needs: prepare
    container: &container-setup
      image: ${{ needs.prepare.outputs.container-image || '' }}
      env: ${{ fromJSON(needs.prepare.outputs.container-env || '{}') }}
      options: ${{ needs.prepare.outputs.container-options || ' ' }}
      ports: ${{ fromJSON(needs.prepare.outputs.container-ports || '[]') }}
      volumes: ${{ fromJSON(needs.prepare.outputs.container-volumes || '[]') }}
      credentials: ${{ fromJSON(needs.prepare.outputs.container-username && format('{{"username":{0},"password":{1}}}',toJSON(needs.prepare.outputs.container-username),toJSON(secrets.container-password)) || '{}') }}
    permissions:
      contents: read
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    outputs:
      build-env: ${{ steps.build-variables.outputs.env }}
      build-commands: ${{ steps.build-variables.outputs.commands }}
      build-artifact: ${{ steps.build-variables.outputs.artifact }}
    steps:
      - if: needs.prepare.outputs.container-image == null
        uses: hoverkraft-tech/ci-github-common/actions/checkout@753288393de1f3d92f687a6761d236ca800f5306 # 0.28.1

      - id: build-variables
        if: inputs.build != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          WORKING_DIRECTORY: ${{ inputs.working-directory }}
          BUILD_INPUT: ${{ inputs.build }}
        with:
          script: |
            const fs = require('node:fs');
            const path = require('node:path');

            let workingDirectory = process.env.WORKING_DIRECTORY || '.';
            if (!path.isAbsolute(workingDirectory)) {
              workingDirectory = path.join(process.env.GITHUB_WORKSPACE, workingDirectory);
            }

            if (!fs.existsSync(workingDirectory)) {
              core.setFailed(`The specified working directory does not exist: ${workingDirectory}`);
              return;
            }

            const buildInput = process.env.BUILD_INPUT.trim();

            let commands = [];
            let env = {};

            // Build commands is a list of command(s), one per line.
            const buildCommandsIsList = !buildInput.trim().startsWith('{') && !buildInput.trim().startsWith('[');
            if (buildCommandsIsList) {
              commands = buildInput.split('\n').map(command => command.trim()).filter(Boolean);
            } else {
              let build;
              try {
                build = JSON.parse(buildInput);
              } catch (error) {
                core.setFailed(`Failed to parse build input as JSON: ${error.message}`);
                return;
              }

              // Build commands is a JSON array of commands
              if (Array.isArray(build)) {
                commands = build;
              }
              // Build commands is a JSON object
              else {
                commands = build.commands ?? ["build"];
                env = build.env ?? {};

                if (build.artifact) {
                  buildArtifact = build.artifact;

                  if (typeof buildArtifact === 'string' || Array.isArray(buildArtifact)) {
                    buildArtifact = {
                      paths: buildArtifact
                    };
                  }

                  if (typeof buildArtifact.paths === 'string') {
                    buildArtifact.paths = buildArtifact.paths.split('\n');
                  } else if (!Array.isArray(buildArtifact.paths)) {
                    return core.setFailed('Build artifact paths must be a string or an array of strings');
                  }

                  buildArtifact.paths = buildArtifact.paths
                    .map(artifact => artifact.trim())
                    .filter(Boolean)
                    .map(artifact => {
                      // FIXME: Workaround to preserve full path to artifact
                      const fullpath = artifact.startsWith('/') ? artifact : path.join(workingDirectory, artifact);

                      // Add a wildcard to the first folder of the path
                      return fullpath.replace(/\/([^/]+)/, '/*$1');
                    }).join('\n');

                  if (!buildArtifact.paths) {
                    return core.setFailed('No valid build artifact paths found');
                  }

                  // Generate a unique name for the artifact
                  buildArtifact.name = `${process.env.GITHUB_JOB}-build-${process.env.GITHUB_RUN_ID}-${Math.random().toString(36).substring(2, 8)}`;

                  core.setOutput('artifact', JSON.stringify(buildArtifact));
                }
              }
            }

            if (commands.some(command => typeof command !== 'string')) {
              core.setFailed('Build commands array must only contain strings');
              return;
            }

            const sanitizedCommands = commands.map(command => command.trim()).filter(Boolean);
            if (!sanitizedCommands.length) {
              core.setFailed('No build commands found');
            }

            core.setOutput('commands', sanitizedCommands.join('\n'));
            core.setOutput('env', JSON.stringify(env));

  lint:
    name: ðŸ‘• Lint
    if: inputs.checks == true && inputs.lint
    needs:
      - prepare
      - setup
    runs-on: ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    container: *container-setup
    # jscpd:ignore-start
    permissions:
      contents: read
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@753288393de1f3d92f687a6761d236ca800f5306 # 0.28.1
        if: needs.prepare.outputs.container-image == null

      - id: oidc
        uses: ChristopherHX/oidc@73eee1ff03fdfce10eda179f617131532209edbd # v3
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
          sparse-checkout: |
            actions
      - run: |
          if [ -f .gitignore ]; then grep -q "self-workflow" .gitignore || echo "self-workflow" >> .gitignore; else echo "self-workflow" >> .gitignore; fi
          if [ -f .dockerignore ]; then grep -q "self-workflow" .dockerignore || echo "self-workflow" >> .dockerignore; else echo "self-workflow" >> .dockerignore; fi
      # jscpd:ignore-end
      - id: preparel-lint-options
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          LINT_INPUT: ${{ inputs.lint }}
        with:
          script: |
            const lintInput = process.env.LINT_INPUT.trim();

            let lintOptions = {};
            if (lintInput && lintInput !== 'true') {
              try {
                const parsed = JSON.parse(lintInput);
                lintOptions = { ...lintOptions, ...parsed };
              } catch (error) {
                core.setFailed(`Failed to parse lint input as JSON: ${error.message}`);
                return;
              }
            }

      - uses: ./self-workflow/actions/lint
        with:
          working-directory: ${{ inputs.working-directory }}
          container: ${{ needs.prepare.outputs.container-image && 'true' || 'false' }}

  build:
    name: ðŸ—ï¸ Build
    if: inputs.checks == true
    runs-on: ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    container: *container-setup
    # jscpd:ignore-start
    needs:
      - prepare
      - setup
    permissions:
      contents: read
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    outputs:
      artifact-id: ${{ steps.build.outputs.artifact-id }}
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@753288393de1f3d92f687a6761d236ca800f5306 # 0.28.1
        if: needs.setup.outputs.build-commands && needs.prepare.outputs.container-image == null

      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        if: needs.setup.outputs.build-commands
        uses: ChristopherHX/oidc@73eee1ff03fdfce10eda179f617131532209edbd # v3
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        if: needs.setup.outputs.build-commands
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
          sparse-checkout: |
            actions
      - if: needs.setup.outputs.build-commands
        run: |
          if [ -f .gitignore ]; then grep -q "self-workflow" .gitignore || echo "self-workflow" >> .gitignore; else echo "self-workflow" >> .gitignore; fi
          if [ -f .dockerignore ]; then grep -q "self-workflow" .dockerignore || echo "self-workflow" >> .dockerignore; else echo "self-workflow" >> .dockerignore; fi
      # jscpd:ignore-end
      - id: build
        if: needs.setup.outputs.build-commands
        uses: ./self-workflow/actions/build
        with:
          working-directory: ${{ inputs.working-directory }}
          build-commands: ${{ needs.setup.outputs.build-commands }}
          build-env: ${{ needs.setup.outputs.build-env }}
          build-secrets: ${{ secrets.build-secrets }}
          build-artifact: ${{ needs.setup.outputs.build-artifact }}
          container: ${{ needs.prepare.outputs.container-image && 'true' || 'false' }}

  test:
    name: ðŸ§ª Test
    if: inputs.checks == true && inputs.test
    runs-on: ${{ inputs.runs-on && fromJson(inputs.runs-on) || 'ubuntu-latest' }}
    container: *container-setup
    needs:
      - prepare
      - setup
      - build
    permissions:
      contents: read
      pull-requests: write
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    steps:
      - uses: hoverkraft-tech/ci-github-common/actions/checkout@753288393de1f3d92f687a6761d236ca800f5306 # 0.28.1
        if: needs.prepare.outputs.container-image == null

      - if: needs.build.outputs.artifact-id && needs.prepare.outputs.container-image == null
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          artifact-ids: ${{ needs.build.outputs.artifact-id }}
          path: "/"

      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        uses: ChristopherHX/oidc@73eee1ff03fdfce10eda179f617131532209edbd # v3
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
          sparse-checkout: |
            actions
      - run: |
          if [ -f .gitignore ]; then grep -q "self-workflow" .gitignore || echo "self-workflow" >> .gitignore; else echo "self-workflow" >> .gitignore; fi
          if [ -f .dockerignore ]; then grep -q "self-workflow" .dockerignore || echo "self-workflow" >> .dockerignore; else echo "self-workflow" >> .dockerignore; fi

      - id: prepare-test-options
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          TEST_INPUT: ${{ inputs.test }}
        with:
          script: |
            const testInput = process.env.TEST_INPUT.trim();

            let testOptions = {};
            if (testInput && testInput !== 'true') {
              try {
                const parsed = JSON.parse(testInput);
                testOptions = { ...testOptions, ...parsed };
              } catch (error) {
                core.setFailed(`Failed to parse test input as JSON: ${error.message}`);
                return;
              }
            }

            if (testOptions.coverage === undefined) {
              testOptions.coverage = 'github';
            }
            core.setOutput('coverage', testOptions.coverage );

            core.setOutput('coverage-files', testOptions['coverage-files'] || '');

      - uses: ./self-workflow/actions/test
        with:
          working-directory: ${{ inputs.working-directory }}
          container: ${{ needs.prepare.outputs.container-image && 'true' || 'false' }}
          coverage: ${{ steps.prepare-test-options.outputs.coverage }}
          coverage-files: ${{ steps.prepare-test-options.outputs.coverage-files }}
          github-token: ${{ github.token }}
